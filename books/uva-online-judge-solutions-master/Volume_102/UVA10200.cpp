/*******************************************************************************
 * Author: Nguyen Truong Duy
 ********************************************************************************/

/* Methodology:
 *	+ Use brute-force approach and prefix sum technique to solve this problem
 *
 *	+ Let f(i) = the number of primes generated by n^2 + n + 41 for all n = 0, ..., i
 *	  Then for a query (a, b), the answer is:
 *		[f(b) - f(a)] * 100.0/ (b - a + 1)
 *	  Assume f(-1) = 0 and a <= b
 *
 *	+ To find f(i), we must solve this problem: Check whether n^2 + n + 41 is a
 *		prime for all n = 0, ..., 10000
 *	+ We can use a brute-force approach to check if n^2 + n + 41 is a prime:
 *		- Generate a list L of all primes less than 10^5
 *		- If x = n^2 + n + 41 has a prime factor in the list L, x is not a prime.
 *		  Otherwise, x is a prime.
 *	+ We can speed up the program by using sieve to check primality for x < 10^6
 *	  (use Sieve of Eratosthenes algorithm). When n >= 10^6, we check the primality
 *	  by the above brute-force algorithm.
 */

#include <cstdio>
#include <vector>
#include <cstring>
#include <cmath>

using namespace std;

const int MAX_PRIME_VAL = 1000000;
const int MAX_BOUND_VAL = 10000;

void getPrefixSumNumPrimeEuler(int prefixSumNumPrimeEuler[MAX_BOUND_VAL + 1], const vector<int> & primeList, const vector<bool> & primeSieve);
void generatePrimeSieveAndList(vector<int> & primeList, vector<bool> & primeSieve);
bool isPrime(int n, const vector<int> & primeList, const vector<bool> & primeSieve);

int main(void)
{
	int prefixSumNumPrimeEuler[MAX_BOUND_VAL + 1];
	vector<int> primeList;
	vector<bool> primeSieve;

	// Preprocessing
	generatePrimeSieveAndList(primeList, primeSieve);
	getPrefixSumNumPrimeEuler(prefixSumNumPrimeEuler, primeList, primeSieve);

	// Querying
	int lower, upper;
	while(scanf("%d %d", &lower, &upper) > 0)
	{
		int lengthQuery = upper - lower + 1;
		int numPrime = prefixSumNumPrimeEuler[upper];
		
		if(lower > 0)
			numPrime -= prefixSumNumPrimeEuler[lower - 1];

		double ratio = numPrime * 10000.0 / lengthQuery;
		ratio = round(ratio);
		ratio /= 100;
		printf("%.2lf\n", ratio);
	}

	return 0;
}

void getPrefixSumNumPrimeEuler(int prefixSumNumPrimeEuler[MAX_BOUND_VAL + 1], const vector<int> & primeList, const vector<bool> & primeSieve)
{
	for(int n = 0; n <= MAX_BOUND_VAL; n++)
	{
		int eulerNum = n * n + n + 41;
		if(isPrime(eulerNum, primeList, primeSieve))
			prefixSumNumPrimeEuler[n] = 1;
		else
			prefixSumNumPrimeEuler[n] = 0;	
	}

	for(int n = 1; n <= MAX_BOUND_VAL; n++)
		prefixSumNumPrimeEuler[n] += prefixSumNumPrimeEuler[n - 1];
}

void generatePrimeSieveAndList(vector<int> & primeList, vector<bool> & primeSieve)
{
	primeSieve.assign(MAX_PRIME_VAL, true);

	primeSieve[0] = primeSieve[1] = false;
	for(int n = 2; n < MAX_PRIME_VAL; n++)
		if(primeSieve[n])
		{
			primeList.push_back(n);

			for(int multipleN = n + n; multipleN < MAX_PRIME_VAL; multipleN += n)
				primeSieve[multipleN] = false;
		}	
}

bool isPrime(int n, const vector<int> & primeList, const vector<bool> & primeSieve)
{
	if(n < MAX_PRIME_VAL)
		return primeSieve[n];
	
	for(int primeInd = 0; primeInd < (int) primeList.size(); ++primeInd)
	{
		int prime = primeList[primeInd];
		if(prime > (n / prime))
			break;

		if(n % prime == 0)
			return false;
	}

	return true;
}
