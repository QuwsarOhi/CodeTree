/*******************************************************************************
 * Author: Nguyen Truong Duy
 ********************************************************************************/

/* Methodology:
 *	+ This is a straight-forward problem.
 *	+ We count the number L of distinct numbers generated by the algorithm.
 *	  If L = mod, then it is a good choice. Otherwise, it is a bad choice.
 *	+ To detect repetition, we can use a bitset structure A
 *	  A[i] = 0 means we have not encountered the number i.
 *	  A[i] = 1 means we have encountered the number i.
 *	+ Once we have a repetition, we can stop the number generation and check
 *	  if L = mod.
 *
 *	+ Time complexity: O(mod) (because we must spend time initializing the bitset
 *		structure which has size mod)
 */

#include <bitset>
#include <cstdio>

using namespace std;

bool isUniformChoice(int step, int mod);

int main(void)
{
	int step, mod;

	while(scanf("%d %d", &step, &mod) > 0)
	{
		bool good = isUniformChoice(step, mod);
		printf("%10d%10d    %s\n\n", step, mod, good ? "Good Choice" : "Bad Choice");
	}
	return 0;
}

bool isUniformChoice(int step, int mod)
{
	bitset<10000000> sieve;
	int seed = 0;
	int numDistinct = 0;

	while(sieve[seed] == 0)
	{
		numDistinct++;
		sieve[seed] = 1;
		seed = (seed + step) % mod;
	}

	if(numDistinct == mod)
		return true;
	return false;
}
